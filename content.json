{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","link":"/2021/10/29/hello-world/"},{"title":"使用汇编编写多线程程序","text":"本文的运行环境为 ubuntu 20.04，编译环境为NASM version 2.14.02。文中代码不使用 pthread 等库。 如果需要在windows下使用汇编编写多线程程序，可以参考这个视频。 准备工作 为了让代码段更加简介，使用了 nasm 的一个头文件库，它将大部分的c语言头文件转换成了汇编可链接的inc文件。 需要注意的是库里面可能有错误： one warning is in place: Not all includes are tested and not all in one include file is tested. Use at your own risk or if in doubt, use your include files. I’ve tried my best but even until today I find errors (typos mostly) 如何使用该头文件库 基本格式如下： 12nasm -f elf64 name.asm -o name.o -i /path/to/linux-nasm/Include-Filesld -melf_x86_64 name.o -o name 需要说明的是：1 nasm进行编译，其中： -f 指定要编译的格式，linux 使用 elf 即可 -o 指定编译后的名称 -i %include指定要查找的目录，可以在 NASMENV 环境变量里设置固定的路径。（万一这个头文件库有奇怪的问题呢，所以不建议设置固定路径） ld 命令是GNU的连接器，将目标文件连接为可执行程序。 也可以用 &amp;&amp; 将上面两条指令合并起来。 nasm和yasm的区别 略。 代码说明 代码部分参考了threads.asm 和 pure-linux-threads-demo，说明部分参考了借由系统调用实现 Linux 原生线程 和 Raw Linux Threads via System Calls 。 汇编参数的传递 当参数少于7个时， 参数从左到右放入寄存器：rdi , rsi , rdx , rcx , r8 , r9 。当参数为7个以上时， 前 6 个与前面一样， 但后面的依次从 “右向左” 放入栈中，即和32位汇编一样。2 下面是第一个创建线程的调用，rdi 中保存的是需要传参的第一个线程的开始地址： 12mov rdi, threadfn1call thread_create 系统调用和一般的函数调用不同。3 在64位 x86_64 Linux 系统中，可用的系统调用定义在 /usr/include/asm/unistd_64.h 头文件中。 每个系统调用都对应一个编号 以及 若干个参数。如果想使用汇编语言调用系统调用，那么在调用之前，需要将系统调用编号存到 rax，将参数依次存到 rdi , rsi , rdx , r10 , r8 , r9 中，然后再执行syscall 指令即可。 每个系统调用的编号和参数列表可以参考此文档 一个输出的调用如下： 123mov rdi, STDOUTmov rax, SYS_writesyscall 如果使用了本文中的库，系统调用可以简化如下： 1syscall write, stdout 栈空间的分配 对于 flags，考虑到我们将用这块内存作为线程栈，我们将选择私有、匿名、向下生长。不过，哪怕设置了向下生长，系统调用 mmap() 仍然会返回内存映射的底部地址。一会儿会用到这一重要信息。于是，事情就简单了：只需要将寄存器的值设置好，而后执行 syscall 指令即可。4 线程的创建 参考文章中已经讲的很清楚了，只针对一点再做一下解释。 最酷的地方来了，我们来看看为什么不需要指令分支；即，为什么我们没有必要检查 rax 的值，来确定是原始线程（返回到调用者）还是新线程（跳转到线程函数）？注意新线程的栈顶部保存着指向线程函数的指针：当函数在新线程返回时，执行序列会跳转到线程函数，且线程栈是空的。而原始线程则会使用原始线程的栈，返回调用者。4 在函数调用的时候，会将当前地址压栈，以方便 ret 的时候返回。这里做了一个类似的操作，将线程函数地址压栈，这样新线程返回的时候就会直接跳转到线程函数的地址，从而达到不检查 rax 的值的效果。 清理现场 使用用 munmap()释放线程栈，以防资源泄漏。但是两份参考代码都没有做这件事。如果你不想要原始线程一直输出的话。 主线程中等价于 pthread_join() 的系统调用是 wait4()。 wait3等待所有的子进程；wait4可以像 waitpid 一样指定要等待的子进程：pid &gt;0表示子进程ID；pid =0表示当前进程组中的子进程；pid =-1表示等待所有子进程；pid &lt;-1表示进程组ID为 pid 绝对值的子进程。5 具体的可以参考之前提到的系统调用编号和参数列表文档。 基础分析 这才是真正有意思的地方了，前面的都只是铺垫，但是我打算之后再展开写，现在先大致的记录一下。 使用 perf 6可以观察到两个线程之间的竞争关系。 使用 ps -a -T 可以得到所有的线程号。使用 sudo perf stat -d -t tid 可以对某线程进行分析，还可以使用 -e 指定具体的PMU计数器。 摘录三个线程中的一个结果如下所示： 1234567891011121314151617Performance counter stats for thread id '45670': 5,980.79 msec task-clock # 0.166 CPUs utilized 276,625 context-switches # 0.046 M/sec 189 cpu-migrations # 0.032 K/sec 0 page-faults # 0.000 K/sec 10,416,963,411 cycles # 1.742 GHz 6,128,956,714 instructions # 0.59 insn per cycle 1,441,731,647 branches # 241.061 M/sec 22,577,430 branch-misses # 1.57% of all branches 1,777,332,012 L1-dcache-loads # 297.174 M/sec 162,317,327 L1-dcache-load-misses # 9.13% of all L1-dcache accesses &lt;not supported&gt; LLC-loads &lt;not supported&gt; LLC-load-misses 36.042847360 seconds time elapsed 参考 1.NASM手册阅读笔记(1) - 编译指令. ↩2.64位汇编参数传递. ↩3.x86_64汇编之六：系统调用（system call）. ↩4.借由系统调用实现 Linux 原生线程. ↩5.wait3和wait4函数. ↩6.perf Examples. ↩","link":"/2021/11/01/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E7%BC%96%E5%86%99%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%A8%8B%E5%BA%8F/"},{"title":"如何确定一条汇编指令的长度","text":"最近在做实验的时候遇到了一些奇怪的问题，为了排除一些选项，不得不确定先一条汇编指令的长度，现记录如下。 当然最简单的方法是用ida反汇编之后直接对照。 如果是一段机器码片段，也有在线反编译器可使用12。 指令和操作数是如何编码的 一条指令由可选的指令前缀、操作码、寻址说明符、偏移量和一个立即数字段组成1。 如下图所示： Opcode 用于指定要执行的操作。操作码的长度大部分为1个字节，也有2或3个字节的。在Intel手册的附录中提供了可供查询的操作码表，但是查起来还是很繁琐，有一些在线文档可以提供操作码到指令和指令到操作码的快速双向查询101113。 以32位版本 inc 为例，它的primary opcode为 $40+r$，这个 $r$ 指的就是寄存器编号 而32位版本寄存器编号如下 64位如下（REX是一个指令前缀）： 所以在32位下，inc eax 的机器码为 40H。但是出现了一个问题，ax 的编号同样为0，难道inc eax 和 inc ax 没有任何的区别吗？ 这就涉及到指令前缀了。 Instruction Prefixes 指令前缀被分成四组，每组中有若干前缀编码。对于每条指令，最多包含四条不同组的前缀。组1到组4可以按任意顺序排列。1 第1组包含 lock 和 repeat。第2组包含段前缀，不同的指令前缀代表了不同的段寄存器。第3组用于修改指令寄存器的默认长度，第4组用于修改默认寻址方式，允许程序在16和32位寻址之间切换。 32位和16位寄存器的使用就涉及到第3组前缀 66H，inc eax 的机器码为 40H ，inc ax 的机器码则为 6640H 。 ModR/M 但是前面还没有涉及到内存，使用内存的指令在主操作码后面都有一个寻址说明，也就是 ModR/M 字段。 ModR/M 字段共占1字节。Mod字段为00、01和10时指示内存，为11时指示寄存器。 在下表中，寄存器编号在最上面，由Reg/Opcode字段确定；下面的四大块中，由ModR/M 字段合在一起可以确定。 以 MOV 相关指令为例，假设现在有机器码 8901H。那么opcode为 89H， 由下表可知，这是 MOV r/m16/32 r16/32，其中r表示寄存器，m表示内存。 但是由于没有 66H 前缀，所以使用32位寄存器，则为 MOV r/m/32 r/32。 将 01 转换为二进制为 00000001b，其中 ModR/M 字段为 000001b，所以查表可得为 [ECX]，Reg/Opcode 字段为 000b， 所以是32位寄存器 EAX。 综上，机器码 8901H 表示的指令为 Mov [ECX], EAX。但是这还不完整，需要添加上默认的段前缀和存储大小指示，完整版本为 Mov dword ptr ds:[ECX],EAX。 此外，如果有偏移会跟在 ModR/M 字段的后面（或者SIB后面）。 但是还留有一个问题，如果需要带寄存器偏移怎么办，比如有指令 Mov dword ptr ds:[ECX+EBX+48H],EAX。 这就涉及到了 SIB 字段。 SIB SIB字段主要用于基址加偏移量寻址等情况。格式如下： 计算公式为 $Base + Index*2^{Scale}$，假设现在SIB字段为91H，转换为二进制即为 10010001b，所以scale为10b，index为010b，base为001b。index对应的寄存器为EDX，base对应的寄存器为ECX。 来看一条机器码，89 9C 91 22 22 22 22 22H。 由上面论述可知，89H 为 MOV r/m/32 r/32；9CH 二进制为 10011100b，所以格式为 Mov [–][–][disp32],EBX；跟在后面的是SIB字段，在上面分析过了，之后的5个16进制，由于偏移量是disp32，所以只取4个，最后一个22属于下一条指令了。 所以这条机器码对应的完整汇编指令是 Mov [ECX+EDX*4+2222222H], EBX 。 有了上面的论述，应该可以从汇编指令写出对应的机器码，也可以将机器码翻译为汇编指令。但是，CPU是怎么完成解码这一过程的呢？ CPU是如何解码指令的 从宏观上来看，fetch window每次从L1 cache中取16B大小的指令。在预解码缓冲区，主要进行指令边界的检测和标记，并对其他前缀进行解码，预解码完成后将发往Instruction queue中等待后续的解码。15 需要注意的是参考中的wikichip在预解码阶段对 IPC(Instruction per cycle) 的论述是错误的。 事实上，预解码阶段已经完成了我们上面论述的部分，而后面的解码阶段主要是将宏指令 (macro-op) 翻译为微指令 (micro-op) ，这就不在本文的论述范围内了。 参考 1.“Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 2A: Instruction Set Reference, A-L,” n.d., 652. ↩2.[原创]IA-32指令解析之操作码 ↩3.[原创]IA-32指令解析之立即数 ↩4.[原创]IA-32指令解析之ModR ↩5.Intel硬编码（一）：Opcode Map、定长指令与指令前缀 ↩6.Intel硬编码（二）：不定长指令、ModR/M与SIB详解（基于P6微架构） ↩7.How to tell the length of an x86 instruction? ↩8.Get size of assembly instructions ↩9.Instruction - ModR/M Byte ↩10.Asm-Dude wiki ↩11.X64 Opcode and Instruction Reference ↩12.online disassembler ↩13.X86 Opcode and Instruction Reference ↩14.Lecture 2 The CPU, Instruction Fetch &amp; Execute ↩15.Skylake (client) - Microarchitectures - Intel ↩","link":"/2021/11/11/%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E4%B8%80%E6%9D%A1%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E7%9A%84%E9%95%BF%E5%BA%A6/"},{"title":"一些汇编小技巧","text":"写一些我自己不知道的汇编小技巧，持续更新。 汇编预处理器指令（The NASM Preprocessor） 本节主要以NASM指令和相关实例为主。如果想要了解更多NASM预处理器指令可以参考这篇文章 或者 NASM手册。 rep指令 rep 指令可以将代码块重复若干次： 1234%rep 5 dec ecx jnz .next %endrep 展开版本如下： 1234567891011121314dec ecxjnz .nextdec ecxjnz .nextdec ecxjnz .nextdec ecxjnz .nextdec ecxjnz .next assign指令 assign指令用于向一个变量赋值，比如 %assign i 100，也可以将变量的值赋给它，比如 %assign i i+1 。 实例 上面两个宏指令看上去很普通，但是我曾经在写benchmark的时候写过这种超级冗余的代码 123456789101112131415161718192021mov r8,100000ALIGN 32.begin:.loop_1: dec ecx jge .loop_2.loop_2: dec ecx jge .loop_3.loop_3: dec ecx jge .loop_4.loop_4:.loop_5: dec ecx jge .loop_6;...;....loop_8000:dec r8jge .begin 有了 rep 和 assign，就可以把它变得很简洁了，从20007行减少到了12行… 当然前面那个也不是手写的，是程序生成的。但是下面这种写法还是方便很多 12345678910111213mov r8,100000ALIGN 32.begin:%assign i 1 %rep 7999 .loop_%+i dec ecx %assign i i+1 jge .loop_%+i%endrep.loop_8000:dec r8jge .begin align 指令 align指令主要用于对齐，可以加快汇编程序的运行速度。通常是添加 nop 达到对齐的目的。需要注意的是align指令后的数字必须是2的幂。 假定以下代码段从地址0（或者4的倍数）开始： 1234add eax,1add ecx,2Align 4add edx,3 那么它的等价表达就是 123456.text: add eax,0x1 ;83 c0 01 add ecx,0x2 ;83 c1 02 nop ;90 nop ;90 add edx,0x3 ;83 c3 03 其中 align 指令还可以使用 0 而不是 nop 作为填充，比如 align 4,db 0，它对应的机器码是 0000 （ 对应的汇编指令是 add BYTE PTR [rax],al ）。 alignb 指令可以用于数据的对齐，作为性能优化的一种手段。 %comment 可以使用%comment 和 %endcomment 来注释多行。 12345%commentadd eax,1add ecx,2add edx,3%endcomment 如何用shell脚本编译汇编程序 只涉及编译汇编程序部分，更详细的论述请参考runoob教程。1 使用shell脚本编译汇编程序的目的是为了多次测试汇编程序或者修改某些关键变量的值。 shell脚本中可以常规的进行赋值，也可以使用语句给变量赋值。在使用的时候只要加上 $ 即可。 123file = &quot;test.asm&quot;for file in `ls /etc`for file in $(ls /etc) 为了控制宏变量的值，我们需要使用 for 循环。以下两种格式都可以： 123456789for var in item1 item2 ... itemNdo command1 command2 ... commandNdonefor var in item1 item2 ... itemN; do command1; command2… done; 在nasm中使用如下格式定义宏变量： -Dmacro[=str] 所以一个完整的shell脚本如下： 12345678910for NOPS in $(seq 0 20) do nasm -f elf64 test.asm -g -DNOPS=$NOPS -o test.o &amp;&amp; ld -m elf_x86_64 test.o -o test echo $(expr $NOPS); perf -d ./testdone 而在汇编程序内，需要有这样的指令，nop 就会被重复 NOPS 次了。 1times NOPS nop 不知道该用在哪 首先介绍下 Code golf，指的是用尽可能短的源代码实现某种算法。 所以在实现时会出现很多奇怪的技巧（几乎都是用于减少汇编代码长度的）3，也许可以用在嵌入式里面。 初始化eax 初始化 eax 为0 当需要初始化 eax 为 0 的时候，不应该使用： 1mov eax,0x0 ;b8 00 00 00 00 而应该使用 1xor eax,eax ;31 c0 这节省了3 byte。当然还有其他的资源和能耗上的考量。6 7 查阅agner的手册可知，在Icelake上，mov r, r/i 和 xor r, r/i 的latency都是1周期，而reciprocal throughput都为0.25（可以并发处理4条独立的相同指令）。 但是如果考虑到CPU的乱序执行的话，xor eax,eax 使用了 eax 作为输入，那么是否存在数据依赖的风险从而导致指令被序列化执行呢？8 考虑如下代码块： 1234add eax,1mov ebx,eaxxor eax,eaxadd eax,ecx 我们希望寄存器能够知道 xor 指令的结果并不依赖于 add 指令的结果。 从网上的存档来看，CPU可以做到的（由于找不到这么老的架构，我没有办法复现）。并且在sandybridge之后，intel引入了 zeroing idioms，许多常见的归零习语（zeroing idioms）被识别，并且寄存器被简单地设置为零。这些优化的完成速度与重命名期间的重命名速度相同（每个周期 4 µOP）。9 也就是说，xor eax, eax 甚至是不占用port资源的。 初始化 eax 为 1 当需要初始化 eax 为 1 的时候，也可以有类似的操作。需要注意的是 dec eax在64位中的机器码为 ff c8，而在32位中的机器码为 48 。 所以后两个表达在32位中是等价的，但是在64位中后面一个要节省一个byte。 123456mov eax,-1 ;b8 ff ff ff ffxor eax,eax ;31 c0dec eax ;ff c8 or eax,-1 ;83 c8 ff 初始化 eax 为 全1 根据peter cordes的答案，可以列出如下选项10 1234567891011121314mov eax, -1 ;b8 ff ff ff ffmov rax, -1 ;48 c7 c0 ff ff ff ffxor eax, eax ;31 c0dec rax ;48 ff c8xor ecx, ecx ;31 c9lea eax, [rcx-1] ;8d 41 ffor eax, -1 ;83 c8 ffpush -1 ;6a ffpop rax ;58 从代码长度上来看，后两个无疑是最佳选择，但是牺牲了一部分性能。由于peter没有写benchmark，只是做了一些定性说明，所以我决定对性能做一个详细的测试。 TL ; DR 选mov的两组。 To be continued. 参考 1.Shell 教程 ↩2.NASM手册阅读笔记(8) - 其他 ↩3.Tips for golfing in x86/x64 machine code ↩4.What does .p2align do in asm code? ↩5.x86 Assembly Language Reference Manual ↩6.Set all bits in CPU register to 1 efficiently ↩7.What is the best way to set a register to zero in x86 assembly: xor, mov or and? ↩8.The Surprising Subtleties of Zeroing a Register ↩9.skylake zeroing idioms ↩10.Set all bits in CPU register to 1 efficiently ↩","link":"/2021/11/29/%E4%B8%80%E4%BA%9B%E6%B1%87%E7%BC%96%E5%B0%8F%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"assembly","slug":"assembly","link":"/tags/assembly/"},{"name":"x86","slug":"x86","link":"/tags/x86/"}],"categories":[{"name":"misc","slug":"misc","link":"/categories/misc/"},{"name":"tutorial","slug":"tutorial","link":"/categories/tutorial/"},{"name":"howto","slug":"howto","link":"/categories/howto/"}]}