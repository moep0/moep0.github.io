{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","link":"/2021/10/29/hello-world/"},{"title":"使用汇编编写多线程程序","text":"本文的运行环境为 ubuntu 20.04，编译环境为NASM version 2.14.02。文中代码不使用 pthread 等库。 如果需要在windows下使用汇编编写多线程程序，可以参考这个视频。 准备工作 为了让代码段更加简介，使用了 nasm 的一个头文件库，它将大部分的c语言头文件转换成了汇编可链接的inc文件。 需要注意的是库里面可能有错误： one warning is in place: Not all includes are tested and not all in one include file is tested. Use at your own risk or if in doubt, use your include files. I’ve tried my best but even until today I find errors (typos mostly) 如何使用该头文件库 基本格式如下： 12nasm -f elf64 name.asm -o name.o -i /path/to/linux-nasm/Include-Filesld -melf_x86_64 name.o -o name 需要说明的是：1 nasm进行编译，其中： -f 指定要编译的格式，linux 使用 elf 即可 -o 指定编译后的名称 -i %include指定要查找的目录，可以在 NASMENV 环境变量里设置固定的路径。（万一这个头文件库有奇怪的问题呢，所以不建议设置固定路径） ld 命令是GNU的连接器，将目标文件连接为可执行程序。 也可以用 &amp;&amp; 将上面两条指令合并起来。 nasm和yasm的区别 略。 代码说明 代码部分参考了threads.asm 和 pure-linux-threads-demo，说明部分参考了借由系统调用实现 Linux 原生线程 和 Raw Linux Threads via System Calls 。 汇编参数的传递 当参数少于7个时， 参数从左到右放入寄存器：rdi , rsi , rdx , rcx , r8 , r9 。当参数为7个以上时， 前 6 个与前面一样， 但后面的依次从 “右向左” 放入栈中，即和32位汇编一样。2 下面是第一个创建线程的调用，rdi 中保存的是需要传参的第一个线程的开始地址： 12mov rdi, threadfn1call thread_create 系统调用和一般的函数调用不同。3 在64位 x86_64 Linux 系统中，可用的系统调用定义在 /usr/include/asm/unistd_64.h 头文件中。 每个系统调用都对应一个编号 以及 若干个参数。如果想使用汇编语言调用系统调用，那么在调用之前，需要将系统调用编号存到 rax，将参数依次存到 rdi , rsi , rdx , r10 , r8 , r9 中，然后再执行syscall 指令即可。 每个系统调用的编号和参数列表可以参考此文档 一个输出的调用如下： 123mov rdi, STDOUTmov rax, SYS_writesyscall 如果使用了本文中的库，系统调用可以简化如下： 1syscall write, stdout 栈空间的分配 对于 flags，考虑到我们将用这块内存作为线程栈，我们将选择私有、匿名、向下生长。不过，哪怕设置了向下生长，系统调用 mmap() 仍然会返回内存映射的底部地址。一会儿会用到这一重要信息。于是，事情就简单了：只需要将寄存器的值设置好，而后执行 syscall 指令即可。4 线程的创建 参考文章中已经讲的很清楚了，只针对一点再做一下解释。 最酷的地方来了，我们来看看为什么不需要指令分支；即，为什么我们没有必要检查 rax 的值，来确定是原始线程（返回到调用者）还是新线程（跳转到线程函数）？注意新线程的栈顶部保存着指向线程函数的指针：当函数在新线程返回时，执行序列会跳转到线程函数，且线程栈是空的。而原始线程则会使用原始线程的栈，返回调用者。4 在函数调用的时候，会将当前地址压栈，以方便 ret 的时候返回。这里做了一个类似的操作，将线程函数地址压栈，这样新线程返回的时候就会直接跳转到线程函数的地址，从而达到不检查 rax 的值的效果。 清理现场 使用用 munmap()释放线程栈，以防资源泄漏。但是两份参考代码都没有做这件事。如果你不想要原始线程一直输出的话。 主线程中等价于 pthread_join() 的系统调用是 wait4()。 wait3等待所有的子进程；wait4可以像 waitpid 一样指定要等待的子进程：pid &gt;0表示子进程ID；pid =0表示当前进程组中的子进程；pid =-1表示等待所有子进程；pid &lt;-1表示进程组ID为 pid 绝对值的子进程。5 具体的可以参考之前提到的系统调用编号和参数列表文档。 基础分析 这才是真正有意思的地方了，前面的都只是铺垫，但是我打算之后再展开写，现在先大致的记录一下。 使用 perf 6可以观察到两个线程之间的竞争关系。 使用 ps -a -T 可以得到所有的线程号。使用 sudo perf stat -d -t tid 可以对某线程进行分析，还可以使用 -e 指定具体的PMU计数器。 摘录三个线程中的一个结果如下所示： 1234567891011121314151617Performance counter stats for thread id '45670': 5,980.79 msec task-clock # 0.166 CPUs utilized 276,625 context-switches # 0.046 M/sec 189 cpu-migrations # 0.032 K/sec 0 page-faults # 0.000 K/sec 10,416,963,411 cycles # 1.742 GHz 6,128,956,714 instructions # 0.59 insn per cycle 1,441,731,647 branches # 241.061 M/sec 22,577,430 branch-misses # 1.57% of all branches 1,777,332,012 L1-dcache-loads # 297.174 M/sec 162,317,327 L1-dcache-load-misses # 9.13% of all L1-dcache accesses &lt;not supported&gt; LLC-loads &lt;not supported&gt; LLC-load-misses 36.042847360 seconds time elapsed 参考 1.NASM手册阅读笔记(1) - 编译指令. ↩2.64位汇编参数传递. ↩3.x86_64汇编之六：系统调用（system call）. ↩4.借由系统调用实现 Linux 原生线程. ↩5.wait3和wait4函数. ↩6.perf Examples. ↩","link":"/2021/11/01/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E7%BC%96%E5%86%99%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%A8%8B%E5%BA%8F/"},{"title":"如何确定一条汇编指令的长度","text":"最近在做实验的时候遇到了一些奇怪的问题，为了排除一些选项，不得不确定先一条汇编指令的长度，现记录如下。 当然最简单的方法是用ida反汇编之后直接对照。 如果是一段机器码片段，也有在线反编译器可使用12。 指令和操作数是如何编码的 一条指令由可选的指令前缀、操作码、寻址说明符、偏移量和一个立即数字段组成1。 如下图所示： Opcode 用于指定要执行的操作。操作码的长度大部分为1个字节，也有2或3个字节的。在Intel手册的附录中提供了可供查询的操作码表，但是查起来还是很繁琐，有一些在线文档可以提供操作码到指令和指令到操作码的快速双向查询101113。 以32位版本 inc 为例，它的primary opcode为 $40+r$，这个 $r$ 指的就是寄存器编号 而32位版本寄存器编号如下 64位如下（REX是一个指令前缀）： 所以在32位下，inc eax 的机器码为 40H。但是出现了一个问题，ax 的编号同样为0，难道inc eax 和 inc ax 没有任何的区别吗？ 这就涉及到指令前缀了。 Instruction Prefixes 指令前缀被分成四组，每组中有若干前缀编码。对于每条指令，最多包含四条不同组的前缀。组1到组4可以按任意顺序排列。1 第1组包含 lock 和 repeat。第2组包含段前缀，不同的指令前缀代表了不同的段寄存器。第3组用于修改指令寄存器的默认长度，第4组用于修改默认寻址方式，允许程序在16和32位寻址之间切换。 32位和16位寄存器的使用就涉及到第3组前缀 66H，inc eax 的机器码为 40H ，inc ax 的机器码则为 6640H 。 ModR/M 但是前面还没有涉及到内存，使用内存的指令在主操作码后面都有一个寻址说明，也就是 ModR/M 字段。 ModR/M 字段共占1字节。Mod字段为00、01和10时指示内存，为11时指示寄存器。 在下表中，寄存器编号在最上面，由Reg/Opcode字段确定；下面的四大块中，由ModR/M 字段合在一起可以确定。 以 MOV 相关指令为例，假设现在有机器码 8901H。那么opcode为 89H， 由下表可知，这是 MOV r/m16/32 r16/32，其中r表示寄存器，m表示内存。 但是由于没有 66H 前缀，所以使用32位寄存器，则为 MOV r/m/32 r/32。 将 01 转换为二进制为 00000001b，其中 ModR/M 字段为 000001b，所以查表可得为 [ECX]，Reg/Opcode 字段为 000b， 所以是32位寄存器 EAX。 综上，机器码 8901H 表示的指令为 Mov [ECX], EAX。但是这还不完整，需要添加上默认的段前缀和存储大小指示，完整版本为 Mov dword ptr ds:[ECX],EAX。 此外，如果有偏移会跟在 ModR/M 字段的后面（或者SIB后面）。 但是还留有一个问题，如果需要带寄存器偏移怎么办，比如有指令 Mov dword ptr ds:[ECX+EBX+48H],EAX。 这就涉及到了 SIB 字段。 SIB SIB字段主要用于基址加偏移量寻址等情况。格式如下： 计算公式为 $Base + Index*2^{Scale}$，假设现在SIB字段为91H，转换为二进制即为 10010001b，所以scale为10b，index为010b，base为001b。index对应的寄存器为EDX，base对应的寄存器为ECX。 来看一条机器码，89 9C 91 22 22 22 22 22H。 由上面论述可知，89H 为 MOV r/m/32 r/32；9CH 二进制为 10011100b，所以格式为 Mov [–][–][disp32],EBX；跟在后面的是SIB字段，在上面分析过了，之后的5个16进制，由于偏移量是disp32，所以只取4个，最后一个22属于下一条指令了。 所以这条机器码对应的完整汇编指令是 Mov [ECX+EDX*4+2222222H], EBX 。 有了上面的论述，应该可以从汇编指令写出对应的机器码，也可以将机器码翻译为汇编指令。但是，CPU是怎么完成解码这一过程的呢？ CPU是如何解码指令的 从宏观上来看，fetch window每次从L1 cache中取16B大小的指令。在预解码缓冲区，主要进行指令边界的检测和标记，并对其他前缀进行解码，预解码完成后将发往Instruction queue中等待后续的解码。15 需要注意的是参考中的wikichip在预解码阶段对 IPC(Instruction per cycle) 的论述是错误的。 事实上，预解码阶段已经完成了我们上面论述的部分，而后面的解码阶段主要是将宏指令 (macro-op) 翻译为微指令 (micro-op) ，这就不在本文的论述范围内了。 参考 1.“Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 2A: Instruction Set Reference, A-L,” n.d., 652. ↩2.[原创]IA-32指令解析之操作码 ↩3.[原创]IA-32指令解析之立即数 ↩4.[原创]IA-32指令解析之ModR ↩5.Intel硬编码（一）：Opcode Map、定长指令与指令前缀 ↩6.Intel硬编码（二）：不定长指令、ModR/M与SIB详解（基于P6微架构） ↩7.How to tell the length of an x86 instruction? ↩8.Get size of assembly instructions ↩9.Instruction - ModR/M Byte ↩10.Asm-Dude wiki ↩11.X64 Opcode and Instruction Reference ↩12.online disassembler ↩13.X86 Opcode and Instruction Reference ↩14.Lecture 2 The CPU, Instruction Fetch &amp; Execute ↩15.Skylake (client) - Microarchitectures - Intel ↩","link":"/2021/11/11/%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E4%B8%80%E6%9D%A1%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E7%9A%84%E9%95%BF%E5%BA%A6/"},{"title":"一些汇编小技巧","text":"写一些我自己不知道的汇编小技巧，持续更新。 汇编预处理器指令（The NASM Preprocessor） 本节主要以NASM指令和相关实例为主。如果想要了解更多NASM预处理器指令可以参考这篇文章 或者 NASM手册。 rep指令 rep 指令可以将代码块重复若干次： 1234%rep 5 dec ecx jnz .next %endrep 展开版本如下： 1234567891011121314dec ecxjnz .nextdec ecxjnz .nextdec ecxjnz .nextdec ecxjnz .nextdec ecxjnz .next assign指令 assign指令用于向一个变量赋值，比如 %assign i 100，也可以将变量的值赋给它，比如 %assign i i+1 。 实例 上面两个宏指令看上去很普通，但是我曾经在写benchmark的时候写过这种超级冗余的代码 123456789101112131415161718192021mov r8,100000ALIGN 32.begin:.loop_1: dec ecx jge .loop_2.loop_2: dec ecx jge .loop_3.loop_3: dec ecx jge .loop_4.loop_4:.loop_5: dec ecx jge .loop_6;...;....loop_8000:dec r8jge .begin 有了 rep 和 assign，就可以把它变得很简洁了，从20007行减少到了12行… 当然前面那个也不是手写的，是程序生成的。但是下面这种写法还是方便很多 12345678910111213mov r8,100000ALIGN 32.begin:%assign i 1 %rep 7999 .loop_%+i dec ecx %assign i i+1 jge .loop_%+i%endrep.loop_8000:dec r8jge .begin align 指令 align指令主要用于对齐，可以加快汇编程序的运行速度。通常是添加 nop 达到对齐的目的。需要注意的是align指令后的数字必须是2的幂。 假定以下代码段从地址0（或者4的倍数）开始： 1234add eax,1add ecx,2Align 4add edx,3 那么它的等价表达就是 123456.text: add eax,0x1 ;83 c0 01 add ecx,0x2 ;83 c1 02 nop ;90 nop ;90 add edx,0x3 ;83 c3 03 其中 align 指令还可以使用 0 而不是 nop 作为填充，比如 align 4,db 0，它对应的机器码是 0000 （ 对应的汇编指令是 add BYTE PTR [rax],al ）。 alignb 指令可以用于数据的对齐，作为性能优化的一种手段。 %comment 可以使用%comment 和 %endcomment 来注释多行。 12345%commentadd eax,1add ecx,2add edx,3%endcomment 如何用shell脚本编译汇编程序 只涉及编译汇编程序部分，更详细的论述请参考runoob教程。1 使用shell脚本编译汇编程序的目的是为了多次测试汇编程序或者修改某些关键变量的值。 shell脚本中可以常规的进行赋值，也可以使用语句给变量赋值。在使用的时候只要加上 $ 即可。 123file = &quot;test.asm&quot;for file in `ls /etc`for file in $(ls /etc) 为了控制宏变量的值，我们需要使用 for 循环。以下两种格式都可以： 123456789for var in item1 item2 ... itemNdo command1 command2 ... commandNdonefor var in item1 item2 ... itemN; do command1; command2… done; 在nasm中使用如下格式定义宏变量： -Dmacro[=str] 所以一个完整的shell脚本如下： 12345678910for NOPS in $(seq 0 20) do nasm -f elf64 test.asm -g -DNOPS=$NOPS -o test.o &amp;&amp; ld -m elf_x86_64 test.o -o test echo $(expr $NOPS); perf -d ./testdone 而在汇编程序内，需要有这样的指令，nop 就会被重复 NOPS 次了。 1times NOPS nop 不知道该用在哪 首先介绍下 Code golf，指的是用尽可能短的源代码实现某种算法。 所以在实现时会出现很多奇怪的技巧（几乎都是用于减少汇编代码长度的）3，也许可以用在嵌入式里面。 初始化eax 初始化 eax 为0 当需要初始化 eax 为 0 的时候，不应该使用： 1mov eax,0x0 ;b8 00 00 00 00 而应该使用 1xor eax,eax ;31 c0 这节省了3 byte。当然还有其他的资源和能耗上的考量。6 7 查阅agner的手册可知，在Icelake上，mov r, r/i 和 xor r, r/i 的latency都是1周期，而reciprocal throughput都为0.25（可以并发处理4条独立的相同指令）。 但是如果考虑到CPU的乱序执行的话，xor eax,eax 使用了 eax 作为输入，那么是否存在数据依赖的风险从而导致指令被序列化执行呢？8 考虑如下代码块： 1234add eax,1mov ebx,eaxxor eax,eaxadd eax,ecx 我们希望寄存器能够知道 xor 指令的结果并不依赖于 add 指令的结果。 从网上的存档来看，CPU可以做到的（由于找不到这么老的架构，我没有办法复现）。并且在sandybridge之后，intel引入了 zeroing idioms，许多常见的归零习语（zeroing idioms）被识别，并且寄存器被简单地设置为零。这些优化的完成速度与重命名期间的重命名速度相同（每个周期 4 µOP）。9 也就是说，xor eax, eax 甚至是不占用port资源的。 初始化 eax 为 1 当需要初始化 eax 为 1 的时候，也可以有类似的操作。需要注意的是 dec eax在64位中的机器码为 ff c8，而在32位中的机器码为 48 。 所以后两个表达在32位中是等价的，但是在64位中后面一个要节省一个byte。 123456mov eax,-1 ;b8 ff ff ff ffxor eax,eax ;31 c0dec eax ;ff c8 or eax,-1 ;83 c8 ff 初始化 eax 为 全1 根据peter cordes的答案，可以列出如下选项10 1234567891011121314mov eax, -1 ;b8 ff ff ff ffmov rax, -1 ;48 c7 c0 ff ff ff ffxor eax, eax ;31 c0dec rax ;48 ff c8xor ecx, ecx ;31 c9lea eax, [rcx-1] ;8d 41 ffor eax, -1 ;83 c8 ffpush -1 ;6a ffpop rax ;58 从代码长度上来看，后两个无疑是最佳选择，但是牺牲了一部分性能。由于peter没有写benchmark，只是做了一些定性说明，所以我决定对性能做一个详细的测试。 TL ; DR 选mov的两组。 To be continued. 参考 1.Shell 教程 ↩2.NASM手册阅读笔记(8) - 其他 ↩3.Tips for golfing in x86/x64 machine code ↩4.What does .p2align do in asm code? ↩5.x86 Assembly Language Reference Manual ↩6.Set all bits in CPU register to 1 efficiently ↩7.What is the best way to set a register to zero in x86 assembly: xor, mov or and? ↩8.The Surprising Subtleties of Zeroing a Register ↩9.skylake zeroing idioms ↩10.Set all bits in CPU register to 1 efficiently ↩","link":"/2021/11/29/%E4%B8%80%E4%BA%9B%E6%B1%87%E7%BC%96%E5%B0%8F%E6%8A%80%E5%B7%A7/"},{"title":"x86架构下μop是如何调度的","text":"在CPU的后端会有多个port用于执行uop。每个port只能用于执行某些uop，而一条uop可能可以在多个port执行，这就涉及到了uop的调度问题。 后端结构 以skylake为例，具体结构如下。如果需要查阅具体的某条指令在哪些port上执行，可以参考agner的instruction_table。比如icelake架构下 mov 指令可以在0156四个端口上执行。 理论调度规则 以下部分翻译自 Abel, Andreas. “Accurate Throughput Prediction of Basic Blocks on Recent Intel Microarchitectures.” Arxiv:2107.14210 [Cs], n.d. 端口在uop被分配到scheduler的时候就确定了（我认为这暗示了端口分配是由renamer完成的）。在一个周期中，最多可以发布4个uop。在下文中，把一个周期内的uop的位置称为 issue slot；例如，在一个周期中最早发布的指令将占用 issue slot 0。一个uop被分配的端口取决于它的 issue slot和上一轮中uop（被发布但是还没有执行的uop）去往的端口。 以下的uop都指可以在多个端口上执行的uop。对于一条给定的uop $m$，$P_{min}$ 是 $m$ 所能使用的所有端口中被分配到最少的未执行的uop的端口。 $P_{min’}$ 是目前使用次数第二少的端口。如果有多个$P_{min}$ （或者$P_{min’}$ ），那么$P_{min}$ （或者$P_{min’}$ ）是端口号码更高的那个，这是因为更高的端口号码功能更少（见后端结构图）。如果 $P_{min}$ 和 $P_{min’}$ 的差值大于等于3，将 $P_{min’}$ 设置为 $P_{min}$ 。（这是为了减少二者的差值） 占用 issue slot 0 和 issue slot 2 的uop会被分配到 $P_{min}$，占用 issue slot 1和 issue slot 3 的uop会被分配到 $P_{min’}$。 一个特殊情况是使用端口2和3的uop，这两个端口涉及到访存而且功能完全相同，所以二者是交替使用的。 实际运行中的调度 在实际运行中的大部分情况都符合调度规则，但是其他组件和CPU经过多年的迭代之后越来越多的内部未知行为（未在手册中进行描述）也可能会对调度产生影响。 上述论文的作者还有一个相应的网站可以模拟运行并预测基本块的吞吐量，但是对下面的corner case应对不好。代码仓库地址。 预测执行对调度的影响 使用Travis Downs的测试代码 12345678_start: mov esi,1000000000.top: xor r9, r10 add r8, rdx imul rax, rbx, 5 dec esi jnz .top 查表可知，执行端口如下所示。其中dec和jnz会宏融合成一条指令，同时BPU会预测该指令将跳转。 inst port 0 port 1 port 5 port 6 xor r,r/i √ √ √ √ add r,r/i √ √ √ √ imul r64,r64,i × √ × × predicted taken jump × × × √ 实验结果如下所示，由于是采样，所以会有~3%的出入。 port 活跃周期 p0 518,350,153 p1 1,244,144,172 p5 1,022,136,023 p6 1,234,819,454 total 1,869,986,150 实验结果和预期是不相符合的（甚至是完全相悖的），按照理论调度规则，p0不应该周期数和p5有如此显著的差异。 一个可能的解释是renamer在确定端口的时候并不知道这个分支指令是会跳转的，所以对他来说p0和p6都是可供分配的，但是预测跳转的指令实际上只能在p6执行，所以p0的活跃周期数就下降了。 指令延迟对调度的影响 但是真的是由于预测执行的影响吗？再看一段代码 12345678_start: mov esi,1000000000.top: xor r9, r10 ror r11, 2 bswap eax dec esi jnz .top 这一次代码的端口分布如下，每条指令的延迟均为1周期。（与之相对比的是 imul 的指令延迟是3周期） 延迟 (latency)：从指令开始到结果可用的时间 吞吐量 (throughput)：指当每条指令的操作数独立于前面的指令时，每个时钟周期可以执行的同类指令的最大数量。 吞吐量的倒数 (reciprocal throughput)：假设在同一线程中有一系列相同类型且相互独立的指令，每条指令的平均核心时钟周期数。 比如div r8 的 reciprocal throughput 为 6，那么一条新的 div 指令可以在前一条指令开始 6 个周期后执行，而它的 latency 为 12，意味着结果需要 12 个周期才可用。再比如 add r,r/i 的 reciprocal throughput 为 0.25，这意味着同一周期可以执行 4 条独立的 add 指令。 inst port 0 port 1 port 5 port 6 xor r,r/i √ √ √ √ ror r,1 √ × × √ bswap r32 × √ √ × predicted taken jump × × × √ 这一次的实验结果如下，可以看到分布明显比上面的例子均匀了。 port 活跃周期 p0 999,165,706 p1 999,691,889 p5 999,023,091 p6 1,001,362,534 total 999,723,598 可以设想到有两个显然的因素会影响端口活跃周期，一个是指令理论可用的端口，另一个是指令的延迟。但是CPU具体是怎么考虑这二者的，我还没有思考清楚，也许之后我会重新完善这一小节。 计数器在线程间是否共享 由理论调度规则可知，renamer应该为每个端口都维护了一个计数器，那么这个计数器是否在线程间共享是一个有趣的话题。 一开始我以为这个计数器是维护了已执行的uop数量，但是重新阅读了理论调度规则之后，这个计数器应该维护的是已经发布（issue）但是还没有执行（non-executed）的uop数量。这就有一些鸡肋了，即使共享似乎切入的粒度要求也很高。 不妨将上面的代码拆成两个线程执行（具体代码参考之前的博客），nop_uop 称为线程1，regular_uop 称为线程2。 123456789101112nop_uop:.loop: imul rax, rbx, 5 jmp .loopregular_uop: mov esi,1000000000 .top: bswap eax dec esi jnz .top jmp regular_uop 其中指令 bswap 可以在端口1和5上执行，imul r64,r64,i 在端口1上执行。如果计数器在线程间共享，那么就会看到 bswap 在端口5上执行，imul 在端口1上执行。 实验记录如下，其中线程1的p0、p5端口和线程2的p0端口应该记录了少量非用户数据，但是不妨碍得到结论。从数据中还是可以清楚的看到，线程2的 bswap 指令在p1和p5端口之间交替执行，并没有出现让出p1的现象。 port 线程1活跃周期 线程2活跃周期 p0 63,088,967 68,022,708 p1 180,219,013,832 95,742,764,738 p5 63,994,200 96,291,124,547 p6 180,330,835,515 192,048,880,421 total 180,998,504,099 192,774,759,297 上述结论和SMotherSpectre5一文的结论并不冲突，该文使用的是时间作为侧信道。（以上面的代码为例的话就是线程2在端口1等待了更长时间才能使用端口1） 编辑：我在StackOverflow上提交了这一小节作为答案，有评论指出p6才是真正的端口压力所在，所以我将 imul 和 bswap 在单个循环中重复了39次，结论没有改变。 参考 1.Abel, Andreas. “Accurate Throughput Prediction of Basic Blocks on Recent Intel Microarchitectures.” Arxiv:2107.14210 [Cs], n.d. ↩2.How are x86 uops scheduled, exactly? ↩3.Skylake (client) - Microarchitectures - Intel ↩4.Method and apparatus for binding instructions to dispatch ports of a reservation station ↩5.Bhattacharyya, Atri, Alexandra Sandulescu, Matthias Neugschwandtner, Alessandro Sorniotti, Babak Falsafi, Mathias Payer, and Anil Kurmus. “SMoTherSpectre: Exploiting Speculative Execution through Port Contention.” Proceedings of the 2019 ACM SIGSAC Conference on Computer and Communications Security, November 6, 2019, 785–800. https://doi.org/10.1145/3319535.3363194. ↩","link":"/2021/12/18/x86%E6%9E%B6%E6%9E%84%E4%B8%8B%CE%BCop%E6%98%AF%E5%A6%82%E4%BD%95%E8%B0%83%E5%BA%A6%E7%9A%84/"},{"title":"互联网中的孤岛","text":"写这篇文章的动机很简单，在写博客的时候时常会看到很多年代久远的博客网站，有的还在顽强的更新，有的已经荒废已久。我尤其喜欢看里面的about me板块，好奇作者现在在做什么呢。 VirtualDub 的作者在时隔8年之后发了一篇新的博客，里面有一句话很打动我： Needless to say, the real world caught up with me a long time ago and I ran out of time/motivation to update the blog, so it sat stagnant for several years. 一个人无拘无束的年纪总会过去，博客的黄金年代也总会过去，但是里面有意思的文章不应该被互联网忘记，所以我把对我而言值得一读的网站和文章分门别类的记录下来。 记录 持续更新中。文章（除首页外）备份采用Wayback Machine 和 Archive.today，如果连这两个网站也都失效了，我还有zotero的本地快照，可以留言让我发送给你。 https://xania.org/ 这个博客其实没写什么技术内容，放在首位的原因是博客的作者开发了Compiler explorer，这是一个交互式工具，允许用户在一个窗口中输入代码，并在另一个窗口中查看其编译结果，支持的compiler非常广泛。 https://johnysswlab.com/ 一个专注于性能调优的博客，暂时没有特别需要保存的文章。 https://easyperf.net/notes/ 同样是专注于性能调优的博客，作者对于PMU的相关分析引导了我入门。 https://csdiy.wiki/ cs自学指南。可能对我来说有用的是体系结构和数学的部分。 https://travisdowns.github.io/ 作者是很nice的一个大叔，StackOverflow上的账号是BeeOnRope，上面的答案对我的帮助也非常大。 http://blog.stuffedcow.net/ 有一些微架构相关的文章，还有一些奇怪的物理实验… 文章和备份 标题 备注 perf Examples （备份） 使用perf Linux 分析器的一些示例 X86 Opcode and Instruction Reference Home （备份） 机器码与助记符的对应，偶尔会用到 Compiler Explorer 神器！ Performance Speed Limits （备份） 讨论了很多现代微处理器的优化策略。 计划 为了少置顶几篇文章，所以我把博客的后续更新计划也放在这里了。 在2022年3月之前完成 TMAM分析介绍和 toplev 介绍 性能调优常用工具介绍（vmstat、iostat、mpstat、sar、top、tcpdump/snoop、perf、bcc+eBPF/DTrace/SystemTap、strace/truss） code alignment 对性能的影响 在2022年6月之前完成 UCB CS61C: Great Ideas in Computer Architecture 学习笔记 UCB CS126 : Probability theory 学习笔记 在2022年年末前完成（或者更久） toplev 源码分析 tuning challenge 4 Modern Microprocessors A 90-Minute Guide! 现代更新拓展版 矢量化指令入门 后记 我不知道这个博客网站我能坚持更新多久，毕竟我一向没有什么毅力。对于一个中文博客网站来说，不能被百度索引到，访问量自然寥寥无几，也没什么评论，正反馈几乎为0。不过写博客更多的是为了记录和提醒自己，所以访问量倒也无关紧要了。但愿我每月能写两篇有质量的博客，在互联网中做一个顽强的孤岛吧。 如果有一天网站没有更新了，我也许只是忘记了我的github密码。","link":"/2021/12/25/%E4%BA%92%E8%81%94%E7%BD%91%E4%B8%AD%E7%9A%84%E5%AD%A4%E5%B2%9B/"}],"tags":[{"name":"assembly","slug":"assembly","link":"/tags/assembly/"},{"name":"x86","slug":"x86","link":"/tags/x86/"}],"categories":[{"name":"misc","slug":"misc","link":"/categories/misc/"},{"name":"tutorial","slug":"tutorial","link":"/categories/tutorial/"},{"name":"howto","slug":"howto","link":"/categories/howto/"}]}