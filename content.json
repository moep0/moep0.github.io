{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","link":"/2021/10/29/hello-world/"},{"title":"使用汇编编写多线程程序","text":"本文的运行环境为 ubuntu 20.04，编译环境为NASM version 2.14.02。文中代码不使用 pthread 等库。 如果需要在windows下使用汇编编写多线程程序，可以参考这个视频。 准备工作 为了让代码段更加简介，使用了 nasm 的一个头文件库，它将大部分的c语言头文件转换成了汇编可链接的inc文件。 需要注意的是库里面可能有错误： one warning is in place: Not all includes are tested and not all in one include file is tested. Use at your own risk or if in doubt, use your include files. I’ve tried my best but even until today I find errors (typos mostly) 如何使用该头文件库 基本格式如下： 12nasm -f elf64 name.asm -o name.o -i /path/to/linux-nasm/Include-Filesld -melf_x86_64 name.o -o name 需要说明的是：1 nasm进行编译，其中： -f 指定要编译的格式，linux 使用 elf 即可 -o 指定编译后的名称 -i %include指定要查找的目录，可以在 NASMENV 环境变量里设置固定的路径。（万一这个头文件库有奇怪的问题呢，所以不建议设置固定路径） ld 命令是GNU的连接器，将目标文件连接为可执行程序。 也可以用 &amp;&amp; 将上面两条指令合并起来。 nasm和yasm的区别 略。 代码说明 代码部分参考了threads.asm 和 pure-linux-threads-demo，说明部分参考了借由系统调用实现 Linux 原生线程 和 Raw Linux Threads via System Calls 。 汇编参数的传递 当参数少于7个时， 参数从左到右放入寄存器：rdi , rsi , rdx , rcx , r8 , r9 。当参数为7个以上时， 前 6 个与前面一样， 但后面的依次从 “右向左” 放入栈中，即和32位汇编一样。2 下面是第一个创建线程的调用，rdi 中保存的是需要传参的第一个线程的开始地址： 12mov rdi, threadfn1call thread_create 系统调用和一般的函数调用不同。3 在64位 x86_64 Linux 系统中，可用的系统调用定义在 /usr/include/asm/unistd_64.h 头文件中。 每个系统调用都对应一个编号 以及 若干个参数。如果想使用汇编语言调用系统调用，那么在调用之前，需要将系统调用编号存到 rax，将参数依次存到 rdi , rsi , rdx , r10 , r8 , r9 中，然后再执行syscall 指令即可。 每个系统调用的编号和参数列表可以参考此文档 一个输出的调用如下： 123mov rdi, STDOUTmov rax, SYS_writesyscall 如果使用了本文中的库，系统调用可以简化如下： 1syscall write, stdout 栈空间的分配 对于 flags，考虑到我们将用这块内存作为线程栈，我们将选择私有、匿名、向下生长。不过，哪怕设置了向下生长，系统调用 mmap() 仍然会返回内存映射的底部地址。一会儿会用到这一重要信息。于是，事情就简单了：只需要将寄存器的值设置好，而后执行 syscall 指令即可。4 线程的创建 参考文章中已经讲的很清楚了，只针对一点再做一下解释。 最酷的地方来了，我们来看看为什么不需要指令分支；即，为什么我们没有必要检查 rax 的值，来确定是原始线程（返回到调用者）还是新线程（跳转到线程函数）？注意新线程的栈顶部保存着指向线程函数的指针：当函数在新线程返回时，执行序列会跳转到线程函数，且线程栈是空的。而原始线程则会使用原始线程的栈，返回调用者。4 在函数调用的时候，会将当前地址压栈，以方便 ret 的时候返回。这里做了一个类似的操作，将线程函数地址压栈，这样新线程返回的时候就会直接跳转到线程函数的地址，从而达到不检查 rax 的值的效果。 清理现场 使用用 munmap()释放线程栈，以防资源泄漏。但是两份参考代码都没有做这件事。如果你不想要原始线程一直输出的话。 主线程中等价于 pthread_join() 的系统调用是 wait4()。 wait3等待所有的子进程；wait4可以像 waitpid 一样指定要等待的子进程：pid &gt;0表示子进程ID；pid =0表示当前进程组中的子进程；pid =-1表示等待所有子进程；pid &lt;-1表示进程组ID为 pid 绝对值的子进程。5 具体的可以参考之前提到的系统调用编号和参数列表文档。 基础分析 这才是真正有意思的地方了，前面的都只是铺垫，但是我打算之后再展开写，现在先大致的记录一下。 使用 perf 6可以观察到两个线程之间的竞争关系。 使用 ps -a -T 可以得到所有的线程号。使用 sudo perf stat -d -t tid 可以对某线程进行分析，还可以使用 -e 指定具体的PMU计数器。 摘录三个线程中的一个结果如下所示： 1234567891011121314151617Performance counter stats for thread id '45670': 5,980.79 msec task-clock # 0.166 CPUs utilized 276,625 context-switches # 0.046 M/sec 189 cpu-migrations # 0.032 K/sec 0 page-faults # 0.000 K/sec 10,416,963,411 cycles # 1.742 GHz 6,128,956,714 instructions # 0.59 insn per cycle 1,441,731,647 branches # 241.061 M/sec 22,577,430 branch-misses # 1.57% of all branches 1,777,332,012 L1-dcache-loads # 297.174 M/sec 162,317,327 L1-dcache-load-misses # 9.13% of all L1-dcache accesses &lt;not supported&gt; LLC-loads &lt;not supported&gt; LLC-load-misses 36.042847360 seconds time elapsed 参考 1.NASM手册阅读笔记(1) - 编译指令. ↩2.64位汇编参数传递. ↩3.x86_64汇编之六：系统调用（system call）. ↩4.借由系统调用实现 Linux 原生线程. ↩5.wait3和wait4函数. ↩6.perf Examples. ↩","link":"/2021/11/01/%E4%BD%BF%E7%94%A8%E6%B1%87%E7%BC%96%E7%BC%96%E5%86%99%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%A8%8B%E5%BA%8F/"},{"title":"如何确定一条汇编指令的长度","text":"最近在做实验的时候遇到了一些奇怪的问题，为了排除一些选项，不得不确定先一条汇编指令的长度，现记录如下。 当然最简单的方法是用ida反汇编之后直接对照。 如果是一段机器码片段，也有在线反编译器可使用12。 指令和操作数是如何编码的 一条指令由可选的指令前缀、操作码、寻址说明符、偏移量和一个立即数字段组成1。 如下图所示： Opcode 用于指定要执行的操作。操作码的长度大部分为1个字节，也有2或3个字节的。在Intel手册的附录中提供了可供查询的操作码表，但是查起来还是很繁琐，有一些在线文档可以提供操作码到指令和指令到操作码的快速双向查询101113。 以32位版本 inc 为例，它的primary opcode为 $40+r$，这个 $r$ 指的就是寄存器编号 而32位版本寄存器编号如下 64位如下（REX是一个指令前缀）： 所以在32位下，inc eax 的机器码为 40H。但是出现了一个问题，ax 的编号同样为0，难道inc eax 和 inc ax 没有任何的区别吗？ 这就涉及到指令前缀了。 Instruction Prefixes 指令前缀被分成四组，每组中有若干前缀编码。对于每条指令，最多包含四条不同组的前缀。组1到组4可以按任意顺序排列。1 第1组包含 lock 和 repeat。第2组包含段前缀，不同的指令前缀代表了不同的段寄存器。第3组用于修改指令寄存器的默认长度，第4组用于修改默认寻址方式，允许程序在16和32位寻址之间切换。 32位和16位寄存器的使用就涉及到第3组前缀 66H，inc eax 的机器码为 40H ，inc ax 的机器码则为 6640H 。 ModR/M 但是前面还没有涉及到内存，使用内存的指令在主操作码后面都有一个寻址说明，也就是 ModR/M 字段。 ModR/M 字段共占1字节。Mod字段为00、01和10时指示内存，为11时指示寄存器。 在下表中，寄存器编号在最上面，由Reg/Opcode字段确定；下面的四大块中，由ModR/M 字段合在一起可以确定。 以 MOV 相关指令为例，假设现在有机器码 8901H。那么opcode为 89H， 由下表可知，这是 MOV r/m16/32 r16/32，其中r表示寄存器，m表示内存。 但是由于没有 66H 前缀，所以使用32位寄存器，则为 MOV r/m/32 r/32。 将 01 转换为二进制为 00000001b，其中 ModR/M 字段为 000001b，所以查表可得为 [ECX]，Reg/Opcode 字段为 000b， 所以是32位寄存器 EAX。 综上，机器码 8901H 表示的指令为 Mov [ECX], EAX。但是这还不完整，需要添加上默认的段前缀和存储大小指示，完整版本为 Mov dword ptr ds:[ECX],EAX。 此外，如果有偏移会跟在 ModR/M 字段的后面（或者SIB后面）。 但是还留有一个问题，如果需要带寄存器偏移怎么办，比如有指令 Mov dword ptr ds:[ECX+EBX+48H],EAX。 这就涉及到了 SIB 字段。 SIB SIB字段主要用于基址加偏移量寻址等情况。格式如下： 计算公式为 $Base + Index*2^{Scale}$，假设现在SIB字段为91H，转换为二进制即为 10010001b，所以scale为10b，index为010b，base为001b。index对应的寄存器为EDX，base对应的寄存器为ECX。 来看一条机器码，89 9C 91 22 22 22 22 22H。 由上面论述可知，89H 为 MOV r/m/32 r/32；9CH 二进制为 10011100b，所以格式为 Mov [–][–][disp32],EBX；跟在后面的是SIB字段，在上面分析过了，之后的5个16进制，由于偏移量是disp32，所以只取4个，最后一个22属于下一条指令了。 所以这条机器码对应的完整汇编指令是 Mov [ECX+EDX*4+2222222H], EBX 。 有了上面的论述，应该可以从汇编指令写出对应的机器码，也可以将机器码翻译为汇编指令。但是，CPU是怎么完成解码这一过程的呢？ CPU是如何解码指令的 从宏观上来看，fetch window每次从L1 cache中取16B大小的指令。在预解码缓冲区，主要进行指令边界的检测和标记，并对其他前缀进行解码，预解码完成后将发往Instruction queue中等待后续的解码。15 需要注意的是参考中的wikichip在预解码阶段对 IPC(Instruction per cycle) 的论述是错误的。 事实上，预解码阶段已经完成了我们上面论述的部分，而后面的解码阶段主要是将宏指令 (macro-op) 翻译为微指令 (micro-op) ，这就不在本文的论述范围内了。 参考 1.“Intel® 64 and IA-32 Architectures Software Developer’s Manual Volume 2A: Instruction Set Reference, A-L,” n.d., 652. ↩2.[原创]IA-32指令解析之操作码 ↩3.[原创]IA-32指令解析之立即数 ↩4.[原创]IA-32指令解析之ModR ↩5.Intel硬编码（一）：Opcode Map、定长指令与指令前缀 ↩6.Intel硬编码（二）：不定长指令、ModR/M与SIB详解（基于P6微架构） ↩7.How to tell the length of an x86 instruction? ↩8.Get size of assembly instructions ↩9.Instruction - ModR/M Byte ↩10.Asm-Dude wiki ↩11.X64 Opcode and Instruction Reference ↩12.online disassembler ↩13.X86 Opcode and Instruction Reference ↩14.Lecture 2 The CPU, Instruction Fetch &amp; Execute ↩15.Skylake (client) - Microarchitectures - Intel ↩","link":"/2021/11/11/%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E4%B8%80%E6%9D%A1%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E7%9A%84%E9%95%BF%E5%BA%A6/"}],"tags":[{"name":"assembly","slug":"assembly","link":"/tags/assembly/"}],"categories":[{"name":"misc","slug":"misc","link":"/categories/misc/"},{"name":"tutorial","slug":"tutorial","link":"/categories/tutorial/"},{"name":"howto","slug":"howto","link":"/categories/howto/"}]}